<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCGraph (containers-data.CCGraph)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">containers-data</a> &#x00BB; CCGraph</nav><header class="odoc-preamble"><h1>Module <code><span>CCGraph</span></code></h1><p>Simple Graph Interface</p><p>A collections of algorithms on (mostly read-only) graph structures. The user provides her own graph structure as a <code>('v, 'e) CCGraph.t</code>, where <code>'v</code> is the type of vertices and <code>'e</code> the type of edges (for instance, <code>'e = ('v * 'v)</code> is perfectly fine in many cases).</p><p>Such a <code>('v, 'e) CCGraph.t</code> structure is a record containing three functions: two relate edges to their origin and destination, and one maps vertices to their outgoing edges. This abstract notion of graph makes it possible to run the algorithms on any user-specific type that happens to have a graph structure.</p><p>Many graph algorithms here take an iterator of vertices as input. The helper module <a href="Iter/index.html"><code>Iter</code></a> contains basic functions for that, as does the <code>iter</code> library on opam. If the user only has a single vertex (e.g., for a topological sort from a given vertex), they can use <code>Iter.return x</code> to build a iter of one element.</p><p><b>status: unstable</b></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.12</li></ul></header><nav class="odoc-toc"><ul><li><a href="#iter-helpers">Iter Helpers</a></li><li><a href="#interfaces-for-graphs">Interfaces for graphs</a></li><li><a href="#bags-of-vertices">Bags of vertices</a></li><li><a href="#traversals">Traversals</a></li><li><a href="#cycles">Cycles</a></li><li><a href="#topological-sort">Topological Sort</a></li><li><a href="#lazy-spanning-tree">Lazy Spanning Tree</a></li><li><a href="#strongly-connected-components">Strongly Connected Components</a></li><li><a href="#pretty-printing-in-the-dot-(graphviz)-format">Pretty printing in the DOT (graphviz) format</a></li><li><a href="#mutable-graph">Mutable Graph</a></li><li><a href="#immutable-graph">Immutable Graph</a></li><li><a href="#misc">Misc</a></li></ul></nav><div class="odoc-content"><h3 id="iter-helpers"><a href="#iter-helpers" class="anchor"></a>Iter Helpers</h3><div class="odoc-spec"><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a iter</span></span><span> = <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A sequence of items of type <code>'a</code>, possibly infinite</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-iter_once" class="anchored"><a href="#type-iter_once" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a iter_once</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-iter">iter</a></span></span></code></div><div class="spec-doc"><p>Iter that should be used only once</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.8</li></ul></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Iter_once" class="anchored"><a href="#exception-Iter_once" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Iter_once</span></span></code></div><div class="spec-doc"><p>Raised when a sequence meant to be used once is used several times.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Iter" class="anchored"><a href="#module-Iter" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Iter/index.html">Iter</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="interfaces-for-graphs"><a href="#interfaces-for-graphs" class="anchor"></a>Interfaces for graphs</h3><p>This interface is designed for oriented graphs with labels on edges</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('v, 'e) t</span></span><span> = <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'e</span> * <span class="type-var">'v</span>)</span> <a href="#type-iter">iter</a></span></span></code></div><div class="spec-doc"><p>Directed graph with vertices of type <code>'v</code> and edges labeled with <code>e'</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-graph" class="anchored"><a href="#type-graph" class="anchor"></a><code><span><span class="keyword">type</span> <span>('v, 'e) graph</span></span><span> = <span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'e</span> * <span class="type-var">'v</span>)</span> <a href="#type-iter">iter</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Make a graph by providing the children function.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-tag_set" class="anchored"><a href="#type-tag_set" class="anchor"></a><code><span><span class="keyword">type</span> <span>'v tag_set</span></span><span> = </span><span>{</span></code><table><tr id="type-tag_set.get_tag" class="anchored"><td class="def record field"><a href="#type-tag_set.get_tag" class="anchor"></a><code><span>get_tag : <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr><tr id="type-tag_set.set_tag" class="anchored"><td class="def record field"><a href="#type-tag_set.set_tag" class="anchor"></a><code><span>set_tag : <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Set tag for the given element</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Tags</p><p>Mutable tags from values of type <code>'v</code> to tags of type <code>bool</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-table" class="anchored"><a href="#type-table" class="anchor"></a><code><span><span class="keyword">type</span> <span>('k, 'a) table</span></span><span> = </span><span>{</span></code><table><tr id="type-table.mem" class="anchored"><td class="def record field"><a href="#type-table.mem" class="anchor"></a><code><span>mem : <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr><tr id="type-table.find" class="anchored"><td class="def record field"><a href="#type-table.find" class="anchor"></a><code><span>find : <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if element not added before</p></li></ul><span class="comment-delim">*)</span></td></tr><tr id="type-table.add" class="anchored"><td class="def record field"><a href="#type-table.add" class="anchor"></a><code><span>add : <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Erases previous binding</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Table</p><p>Mutable table with keys <code>'k</code> and values <code>'a</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-set" class="anchored"><a href="#type-set" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a set</span></span><span> = <span><span>( <span class="type-var">'a</span>, unit )</span> <a href="#type-table">table</a></span></span></code></div><div class="spec-doc"><p>Mutable set</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_table" class="anchored"><a href="#val-mk_table" class="anchor"></a><code><span><span class="keyword">val</span> mk_table : 
  <span>eq:<span>( <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?hash:<span>( <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'k</span>, <span class="type-var">'a</span> )</span> <a href="#type-table">table</a></span></span></code></div><div class="spec-doc"><p>Default implementation for <a href="#table">Table</a>: a <code>Hashtbl</code>.t.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_map" class="anchored"><a href="#val-mk_map" class="anchor"></a><code><span><span class="keyword">val</span> mk_map : <span>cmp:<span>( <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'k</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'k</span>, <span class="type-var">'a</span> )</span> <a href="#type-table">table</a></span></span></code></div><div class="spec-doc"><p>Use a <code>Map</code>.S underneath.</p></div></div><h3 id="bags-of-vertices"><a href="#bags-of-vertices" class="anchor"></a>Bags of vertices</h3><div class="odoc-spec"><div class="spec type" id="type-bag" class="anchored"><a href="#type-bag" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a bag</span></span><span> = </span><span>{</span></code><table><tr id="type-bag.push" class="anchored"><td class="def record field"><a href="#type-bag.push" class="anchor"></a><code><span>push : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td></tr><tr id="type-bag.is_empty" class="anchored"><td class="def record field"><a href="#type-bag.is_empty" class="anchor"></a><code><span>is_empty : <span>unit <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr><tr id="type-bag.pop" class="anchored"><td class="def record field"><a href="#type-bag.pop" class="anchor"></a><code><span>pop : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>raises some exception is empty</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Bag of elements of type <code>'a</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_queue" class="anchored"><a href="#val-mk_queue" class="anchor"></a><code><span><span class="keyword">val</span> mk_queue : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-bag">bag</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_stack" class="anchored"><a href="#val-mk_stack" class="anchor"></a><code><span><span class="keyword">val</span> mk_stack : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-bag">bag</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_heap" class="anchored"><a href="#val-mk_heap" class="anchor"></a><code><span><span class="keyword">val</span> mk_heap : <span>leq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-bag">bag</a></span></span></code></div><div class="spec-doc"><p><code>mk_heap ~leq</code> makes a priority queue where <code>leq x y = true</code> means that <code>x</code> is smaller than <code>y</code> and should be prioritary.</p></div></div><h3 id="traversals"><a href="#traversals" class="anchor"></a>Traversals</h3><div class="odoc-spec"><div class="spec module" id="module-Traverse" class="anchored"><a href="#module-Traverse" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Traverse/index.html">Traverse</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="cycles"><a href="#cycles" class="anchor"></a>Cycles</h3><div class="odoc-spec"><div class="spec value" id="val-is_dag" class="anchored"><a href="#val-is_dag" class="anchor"></a><code><span><span class="keyword">val</span> is_dag : 
  <span>tbl:<span><span class="type-var">'v</span> <a href="#type-set">set</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>eq:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">_</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'v</span> <a href="#type-iter">iter</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>is_dag ~graph vs</code> returns <code>true</code> if the subset of <code>graph</code> reachable from <code>vs</code> is acyclic.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.18</li></ul></div></div><h3 id="topological-sort"><a href="#topological-sort" class="anchor"></a>Topological Sort</h3><div class="odoc-spec"><div class="spec exception" id="exception-Has_cycle" class="anchored"><a href="#exception-Has_cycle" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Has_cycle</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-topo_sort" class="anchored"><a href="#val-topo_sort" class="anchor"></a><code><span><span class="keyword">val</span> topo_sort : 
  <span>eq:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>tbl:<span><span class="type-var">'v</span> <a href="#type-set">set</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'v</span> <a href="#type-iter">iter</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'v</span> list</span></span></code></div><div class="spec-doc"><p><code>topo_sort ~graph seq</code> returns a list of vertices <code>l</code> where each element of <code>l</code> is reachable from <code>seq</code>. The list is sorted in a way such that if <code>v -&gt; v'</code> in the graph, then <code>v</code> comes before <code>v'</code> in the list (i.e. has a smaller index). Basically <code>v -&gt; v'</code> means that <code>v</code> is smaller than <code>v'</code>. See <a href="https://en.wikipedia.org/wiki/Topological_sorting">wikipedia</a>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">eq</span> <p>equality predicate on vertices (default <code>(=)</code>).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">rev</span> <p>if true, the dependency relation is inverted (<code>v -&gt; v'</code> means <code>v'</code> occurs before <code>v</code>).</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Has_cycle</span> <p>if the graph is not a DAG.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-topo_sort_tag" class="anchored"><a href="#val-topo_sort_tag" class="anchor"></a><code><span><span class="keyword">val</span> topo_sort_tag : 
  <span>eq:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>tags:<span><span class="type-var">'v</span> <a href="#type-tag_set">tag_set</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'v</span> <a href="#type-iter">iter</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'v</span> list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-topo_sort"><code>topo_sort</code></a> but uses an explicit tag set.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Has_cycle</span> <p>if the graph is not a DAG.</p></li></ul></div></div><h3 id="lazy-spanning-tree"><a href="#lazy-spanning-tree" class="anchor"></a>Lazy Spanning Tree</h3><div class="odoc-spec"><div class="spec module" id="module-Lazy_tree" class="anchored"><a href="#module-Lazy_tree" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lazy_tree/index.html">Lazy_tree</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-spanning_tree" class="anchored"><a href="#val-spanning_tree" class="anchor"></a><code><span><span class="keyword">val</span> spanning_tree : 
  <span>tbl:<span><span class="type-var">'v</span> <a href="#type-set">set</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></span></span></code></div><div class="spec-doc"><p><code>spanning_tree ~graph v</code> computes a lazy spanning tree that has <code>v</code> as a root. The table <code>tbl</code> is used for the memoization part.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spanning_tree_tag" class="anchored"><a href="#val-spanning_tree_tag" class="anchor"></a><code><span><span class="keyword">val</span> spanning_tree_tag : 
  <span>tags:<span><span class="type-var">'v</span> <a href="#type-tag_set">tag_set</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></span></span></code></div></div><h3 id="strongly-connected-components"><a href="#strongly-connected-components" class="anchor"></a>Strongly Connected Components</h3><div class="odoc-spec"><div class="spec type" id="type-scc_state" class="anchored"><a href="#type-scc_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'v scc_state</span></span></code></div><div class="spec-doc"><p>Hidden state for <a href="#val-scc"><code>scc</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scc" class="anchored"><a href="#val-scc" class="anchor"></a><code><span><span class="keyword">val</span> scc : 
  <span>tbl:<span><span>( <span class="type-var">'v</span>, <span><span class="type-var">'v</span> <a href="#type-scc_state">scc_state</a></span> )</span> <a href="#type-table">table</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>graph:<span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'v</span> <a href="#type-iter">iter</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'v</span> list</span> <a href="#type-iter_once">iter_once</a></span></span></code></div><div class="spec-doc"><p>Strongly connected components reachable from the given vertices. Each component is a list of vertices that are all mutually reachable in the graph. The components are explored in a topological order (if C1 and C2 are components, and C1 points to C2, then C2 will be yielded before C1). Uses <a href="https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm">Tarjan's algorithm</a>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">tbl</span> <p>table used to map nodes to some hidden state.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Iter_once</span> <p>if the result is iterated on more than once.</p></li></ul></div></div><h3 id="pretty-printing-in-the-dot-(graphviz)-format"><a href="#pretty-printing-in-the-dot-(graphviz)-format" class="anchor"></a>Pretty printing in the DOT (graphviz) format</h3><p>Example (print divisors from <code>42</code>):</p><pre><code>let open CCGraph in
let open Dot in
with_out &quot;/tmp/truc.dot&quot;
  (fun out -&gt;
     pp ~attrs_v:(fun i -&gt; [`Label (string_of_int i)]) ~graph:divisors_graph out 42
  )</code></pre><div class="odoc-spec"><div class="spec module" id="module-Dot" class="anchored"><a href="#module-Dot" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Dot/index.html">Dot</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="mutable-graph"><a href="#mutable-graph" class="anchor"></a>Mutable Graph</h3><div class="odoc-spec"><div class="spec type" id="type-mut_graph" class="anchored"><a href="#type-mut_graph" class="anchor"></a><code><span><span class="keyword">type</span> <span>('v, 'e) mut_graph</span></span><span> = </span><span>{</span></code><table><tr id="type-mut_graph.graph" class="anchored"><td class="def record field"><a href="#type-mut_graph.graph" class="anchor"></a><code><span>graph : <span><span>( <span class="type-var">'v</span>, <span class="type-var">'e</span> )</span> <a href="#type-t">t</a></span>;</span></code></td></tr><tr id="type-mut_graph.add_edge" class="anchored"><td class="def record field"><a href="#type-mut_graph.add_edge" class="anchor"></a><code><span>add_edge : <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td></tr><tr id="type-mut_graph.remove" class="anchored"><td class="def record field"><a href="#type-mut_graph.remove" class="anchor"></a><code><span>remove : <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_mut_tbl" class="anchored"><a href="#val-mk_mut_tbl" class="anchor"></a><code><span><span class="keyword">val</span> mk_mut_tbl : 
  <span>eq:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?hash:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'v</span>, <span class="type-var">'a</span> )</span> <a href="#type-mut_graph">mut_graph</a></span></span></code></div><div class="spec-doc"><p>Make a new mutable graph from a Hashtbl. Edges are labelled with type <code>'a</code>.</p></div></div><h3 id="immutable-graph"><a href="#immutable-graph" class="anchor"></a>Immutable Graph</h3><p>A classic implementation of a graph structure on totally ordered vertices, with unlabelled edges. The graph allows to add and remove edges and vertices, and to iterate on edges and vertices.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-MAP" class="anchored"><a href="#module-type-MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP/index.html">MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> (<a href="Map/index.html#argument-1-O">O</a> : <span class="xref-unresolved">Stdlib</span>.Map.OrderedType) : <a href="module-type-MAP/index.html">MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MAP/index.html#type-vertex">vertex</a> = <span class="xref-unresolved">O</span>.t</span></span></code></div></div><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span>eq:<span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'v</span> * <span class="type-var">'v</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'v</span>, unit )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_list l</code> makes a graph from a list of pairs of vertices. Each pair <code>(a,b)</code> is an edge from <code>a</code> to <code>b</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">eq</span> <p>equality used to compare vertices.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_hashtbl" class="anchored"><a href="#val-of_hashtbl" class="anchor"></a><code><span><span class="keyword">val</span> of_hashtbl : <span><span><span>( <span class="type-var">'v</span>, <span><span class="type-var">'v</span> list</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'v</span>, unit )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_hashtbl tbl</code> makes a graph from a hashtable that maps vertices to lists of children.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_fun" class="anchored"><a href="#val-of_fun" class="anchor"></a><code><span><span class="keyword">val</span> of_fun : <span><span>( <span><span class="type-var">'v</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'v</span> list</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'v</span>, unit )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_fun f</code> makes a graph out of a function that maps a vertex to the list of its children. The function is assumed to be deterministic.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-divisors_graph" class="anchored"><a href="#val-divisors_graph" class="anchor"></a><code><span><span class="keyword">val</span> divisors_graph : <span><span>( int, unit )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>n</code> points to all its strict divisors.</p></div></div></div></body></html>