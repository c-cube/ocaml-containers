<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lift_constants (ocaml.Lift_constants)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml</a> &#x00BB; Lift_constants</nav><header class="odoc-preamble"><h1>Module <code><span>Lift_constants</span></code></h1><p>The aim of this pass is to assign symbols to values known to be constant (in other words, whose values we know at compile time), with appropriate sharing of constants, and replace the occurrences of the constants with their corresponding symbols.</p><p>This pass uses the results of two other passes, <code>Inconstant_idents</code> and <code>Alias_analysis</code>. The relationship between these two deserves some attention.</p><p><code>Inconstant_idents</code> is a &quot;backwards&quot; analysis that propagates implications about inconstantness of variables and set of closures IDs.</p><p><code>Alias_analysis</code> is a &quot;forwards&quot; analysis that is analogous to the propagation of <code>Simple_value_approx.t</code> values during <code>Inline_and_simplify</code>. It gives us information about relationships between values but not actually about their constantness.</p><p>Combining these two into a single pass has been attempted previously, but was not thought to be successful; this experiment could be repeated in the future. (If &quot;constant&quot; is considered as &quot;top&quot; and &quot;inconstant&quot; is considered as &quot;bottom&quot;, then <code>Alias_analysis</code> corresponds to a least fixed point and <code>Inconstant_idents</code> corresponds to a greatest fixed point.)</p><p>At a high level, this pass operates as follows. Symbols are assigned to variables known to be constant and their defining expressions examined. Based on the results of <code>Alias_analysis</code>, we simplify the destructive elements within the defining expressions (specifically, projection of fields from blocks), to eventually yield <code>Flambda.constant_defining_value</code>s that are entirely constructive. These will be bound to symbols in the resulting program.</p><p>Another approach to this pass could be to only use the results of <code>Inconstant_idents</code> and then repeatedly lift constants and run <code>Inline_and_simplify</code> until a fixpoint. It was thought more robust to instead use <code>Alias_analysis</code>, where the fixpointing involves a less complicated function.</p><p>We still run <code>Inline_and_simplify</code> once after this pass since the lifting of constants may enable more functions to become closed; the simplification pass provides an easy way of cleaning up (e.g. making sure <code>free_vars</code> maps in sets of closures are correct).</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-lift_constants"><a href="#val-lift_constants" class="anchor"></a><code><span><span class="keyword">val</span> lift_constants : 
  <span><a href="../Flambda/index.html#type-program">Flambda.program</a> <span class="arrow">&#45;&gt;</span></span>
  <span>backend:<span>(<span class="keyword">module</span> <a href="../Backend_intf/module-type-S/index.html">Backend_intf.S</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Flambda/index.html#type-program">Flambda.program</a></span></code></div></div></div></body></html>