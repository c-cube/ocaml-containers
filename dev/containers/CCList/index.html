<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCList (containers.CCList)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">containers</a> &#x00BB; CCList</nav><h1>Module <code>CCList</code></h1><h2 id="complements-to-list"><a href="#complements-to-list" class="anchor"></a>Complements to list</h2><nav class="toc"><ul><li><a href="#indices">Indices</a></li><li><a href="#set-operators">Set Operators</a></li><li><a href="#other-constructors">Other Constructors</a></li><li><a href="#association-lists">Association Lists</a></li><li><a href="#references-on-lists">References on Lists</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#infix-operators">Infix Operators</a></li><li><a href="#io">IO</a></li></ul></nav></header><dl><dt class="spec type" id="type-iter"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter</span></code><code> = <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Fast internal iterator.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec type" id="type-gen"><a href="#type-gen" class="anchor"></a><code><span class="keyword">type</span> <span>'a gen</span></code><code> = unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec type" id="type-printer"><a href="#type-printer" class="anchor"></a><code><span class="keyword">type</span> <span>'a printer</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-random_gen"><a href="#type-random_gen" class="anchor"></a><code><span class="keyword">type</span> <span>'a random_gen</span></code><code> = Stdlib.Random.State.t <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl><div><div class="spec include"><div class="doc"><p><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">Documentation for the standard List module</a></p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> Stdlib.List</code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>!'a t</span></code><code> = <span><span class="type-var">'a</span> list</span></code><code> = </code><table class="variant"><tr id="type-t.([])" class="anchored"><td class="def constructor"><a href="#type-t.([])" class="anchor"></a><code>| </code><code><span class="constructor">([])</span></code></td></tr><tr id="type-t.(::)" class="anchored"><td class="def constructor"><a href="#type-t.(::)" class="anchor"></a><code>| </code><code><span class="constructor">(::)</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val</span> hd : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val</span> tl : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val</span> rev_append : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span><span><span class="type-var">'a</span> list</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span class="keyword">val</span> concat_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-fold_left_map"><a href="#val-fold_left_map" class="anchor"></a><code><span class="keyword">val</span> fold_left_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span></code></dt><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dt class="spec value" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span class="keyword">val</span> rev_map2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span></code></dt><dt class="spec value" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span class="keyword">val</span> fold_left2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span class="keyword">val</span> fold_right2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span class="keyword">val</span> for_all2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span class="keyword">val</span> exists2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span class="keyword">val</span> memq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span class="keyword">val</span> assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span class="keyword">val</span> mem_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span class="keyword">val</span> remove_assq : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></code></dt><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span class="keyword">val</span> stable_sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span class="keyword">val</span> fast_sort : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span class="type-var">'a</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt></dl></details></div></div></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> list</span></code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> is <code>[]</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty l</code> returns <code>true</code> iff <code>l = []</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f [a0; a1; …; an]</code> applies function <code>f</code> in turn to <code>a0; a1; …; an</code>. Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.map&quot;"><code>List</code>.map</span>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>l &gt;|= f</code> is the infix version of <code>map</code> with reversed arguments.</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>append l1 l2</code> returns the list that is the concatenation of <code>l1</code> and <code>l2</code>. Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.append&quot;"><code>List</code>.append</span>.</p></dd></dl><dl><dt class="spec value" id="val-cons_maybe"><a href="#val-cons_maybe" class="anchor"></a><code><span class="keyword">val</span> cons_maybe : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cons_maybe (Some x) l</code> is <code>x :: l</code>. <code>cons_maybe None l</code> is <code>l</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-cons'"><a href="#val-cons'" class="anchor"></a><code><span class="keyword">val</span> cons' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cons' l x</code> is the same as <code>x :: l</code>. This is convenient for fold functions such as <span class="xref-unresolved" title="unresolved reference to &quot;List.fold_left&quot;"><code>List</code>.fold_left</span> or <span class="xref-unresolved" title="unresolved reference to &quot;Array.fold_left&quot;"><code>Array</code>.fold_left</span>.</p><dl><dt>since</dt><dd>NEXT_RELEASE</dd></dl></dd></dl><dl><dt class="spec value" id="val-(@)"><a href="#val-(@)" class="anchor"></a><code><span class="keyword">val</span> (@) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>l1 @ l2</code> is like <code>append l1 l2</code>. Concatenate the two lists <code>l1</code> and <code>l2</code>.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter p l</code> returns all the elements of the list <code>l</code> that satisfy the predicate <code>p</code>. The order of the elements in the input list <code>l</code> is preserved. Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.filter&quot;"><code>List</code>.filter</span>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>fold_right f [a1; …; an] b</code> is <code>f a1 (f a2 ( … (f an b) … ))</code>. Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.fold_right&quot;"><code>List</code>.fold_right</span>.</p></dd></dl><dl><dt class="spec value" id="val-fold_while"><a href="#val-fold_while" class="anchor"></a><code><span class="keyword">val</span> fold_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span>[ `Stop <span>| `Continue</span> ]</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_while f init l</code> folds until a stop condition via <code>('a, `Stop)</code> is indicated by the accumulator.</p><dl><dt>since</dt><dd>0.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_map f init l</code> is a <code>fold_left</code>-like function, but it also maps the list to another list.</p><dl><dt>since</dt><dd>0.14</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map_i"><a href="#val-fold_map_i" class="anchor"></a><code><span class="keyword">val</span> fold_map_i : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_map_i f init l</code> is a <code>foldi</code>-like function, but it also maps the list to another list.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_on_map"><a href="#val-fold_on_map" class="anchor"></a><code><span class="keyword">val</span> fold_on_map : <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span>reduce:<span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p><code>fold_on_map ~f ~reduce init l</code> combines <code>map f</code> and <code>fold_left reduce init</code> in one operation.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-scan_left"><a href="#val-scan_left" class="anchor"></a><code><span class="keyword">val</span> scan_left : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'acc</span> list</span></code></dt><dd><p><code>scan_left f init l</code> returns the list <code>[init; f init x0; f (f init x0) x1; …]</code> where <code>x0</code>, <code>x1</code>, etc. are the elements of <code>l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>reduce f (hd::tl)</code> returns <code>Some (fold_left f hd tl)</code>. If <code>l</code> is empty, then <code>None</code> is returned.</p><dl><dt>since</dt><dd>3.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-reduce_exn"><a href="#val-reduce_exn" class="anchor"></a><code><span class="keyword">val</span> reduce_exn : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>reduce_exn</code> is the unsafe version of <a href="index.html#val-reduce"><code>reduce</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the given list is empty.</p></dd></dl><dl><dt>since</dt><dd>3.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_map2"><a href="#val-fold_map2" class="anchor"></a><code><span class="keyword">val</span> fold_map2 : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'c</span> list</span></code></dt><dd><p><code>fold_map2 f init l1 l2</code> is to <code>fold_map</code> what <code>List.map2</code> is to <code>List.map</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>0.16</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_filter_map"><a href="#val-fold_filter_map" class="anchor"></a><code><span class="keyword">val</span> fold_filter_map : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_filter_map f init l</code> is a <code>fold_left</code>-like function, but also generates a list of output in a way similar to <a href="index.html#val-filter_map"><code>filter_map</code></a>.</p><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_filter_map_i"><a href="#val-fold_filter_map_i" class="anchor"></a><code><span class="keyword">val</span> fold_filter_map_i : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_filter_map_i f init l</code> is a <code>foldi</code>-like function, but also generates a list of output in a way similar to <a href="index.html#val-filter_map"><code>filter_map</code></a>.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_flat_map"><a href="#val-fold_flat_map" class="anchor"></a><code><span class="keyword">val</span> fold_flat_map : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_flat_map f init l</code> is a <code>fold_left</code>-like function, but it also maps the list to a list of lists that is then <code>flatten</code>'d.</p><dl><dt>since</dt><dd>0.14</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_flat_map_i"><a href="#val-fold_flat_map_i" class="anchor"></a><code><span class="keyword">val</span> fold_flat_map_i : <span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>fold_flat_map_i f init l</code> is a <code>fold_left</code>-like function, but it also maps the list to a list of lists that is then <code>flatten</code>'d.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>count p l</code> counts how many elements of <code>l</code> satisfy predicate <code>p</code>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-count_true_false"><a href="#val-count_true_false" class="anchor"></a><code><span class="keyword">val</span> count_true_false : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> int * int</code></dt><dd><p><code>count_true_false p l</code> returns a pair <code>(int1,int2)</code> where <code>int1</code> is the number of elements in <code>l</code> that satisfy the predicate <code>p</code>, and <code>int2</code> the number of elements that do not satisfy <code>p</code>.</p><dl><dt>since</dt><dd>2.4</dd></dl></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>init len f</code> is <code>f 0; f 1; …; f (len-1)</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if len &lt; 0.</p></dd></dl><dl><dt>since</dt><dd>0.6</dd></dl></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p><code>combine [a1; …; an] [b1; …; bn]</code> is <code>[(a1,b1); …; (an,bn)]</code>. Transform two lists into a list of pairs. Like <span class="xref-unresolved" title="unresolved reference to &quot;List.combine&quot;"><code>List</code>.combine</span> but tail-recursive.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the lists have distinct lengths.</p></dd></dl><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-combine_gen"><a href="#val-combine_gen" class="anchor"></a><code><span class="keyword">val</span> combine_gen : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p><code>combine_gen l1 l2</code> transforms two lists into a <code>gen</code> of pairs. Lazy version of <a href="index.html#val-combine"><code>combine</code></a>. Unlike <a href="index.html#val-combine"><code>combine</code></a>, it does not fail if the lists have different lengths; instead, the output has as many pairs as the smallest input list.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-combine_shortest"><a href="#val-combine_shortest" class="anchor"></a><code><span class="keyword">val</span> combine_shortest : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></code></dt><dd><p><code>combine_shortest [a1; …; am] [b1; …; bn]</code> is <code>[(a1,b1); …; (am,bm)]</code> if m &lt;= n. Like <a href="index.html#val-combine"><code>combine</code></a> but stops at the shortest list rather than raising.</p><dl><dt>since</dt><dd>3.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>split [(a1,b1); …; (an,bn)]</code> is <code>([a1; …; an], [b1; …; bn])</code>. Transform a list of pairs into a pair of lists. A tail-recursive version of <span class="xref-unresolved" title="unresolved reference to &quot;List.split&quot;"><code>List</code>.split</span>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare cmp l1 l2</code> compares the two lists <code>l1</code> and <code>l2</code> using the given comparison function <code>cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val</span> compare_lengths : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_lengths l1 l2</code> compare the lengths of the two lists <code>l1</code> and <code>l2</code>. Equivalent to <code>compare (length l1) (length l2)</code> but more efficient.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val</span> compare_length_with : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_length_with l x</code> compares the length of the list <code>l</code> to an integer <code>x</code>. Equivalent to <code>compare (length l) x</code> but more efficient.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal p l1 l2</code> returns <code>true</code> if <code>l1</code> and <code>l2</code> are equal.</p></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>flat_map f l</code> maps and flattens at the same time (safe). Evaluation order is not guaranteed.</p></dd></dl><dl><dt class="spec value" id="val-flat_map_i"><a href="#val-flat_map_i" class="anchor"></a><code><span class="keyword">val</span> flat_map_i : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>flat_map_i f l</code> maps with index and flattens at the same time (safe). Evaluation order is not guaranteed.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>flatten [l1]; [l2]; …</code> concatenates a list of lists. Safe version of <span class="xref-unresolved" title="unresolved reference to &quot;List.flatten&quot;"><code>List</code>.flatten</span>.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>product comb l1 l2</code> computes the cartesian product of the two lists, with the given combinator <code>comb</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_product"><a href="#val-fold_product" class="anchor"></a><code><span class="keyword">val</span> fold_product : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>fold_product f init l1 l2</code> applies the function <code>f</code> with the accumulator <code>init</code> on all the pair of elements of <code>l1</code> and <code>l2</code>. Fold on the cartesian product.</p></dd></dl><dl><dt class="spec value" id="val-cartesian_product"><a href="#val-cartesian_product" class="anchor"></a><code><span class="keyword">val</span> cartesian_product : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cartesian_product [[l1]; [l2]; …; [ln]]</code> produces the cartesian product of this list of lists, by returning all the ways of picking one element per sublist. <b>NOTE</b> the order of the returned list is unspecified. For example:</p><pre><code class="ml"># cartesian_product [[1;2];[3];[4;5;6]] |&gt; sort =
[[1;3;4];[1;3;5];[1;3;6];[2;3;4];[2;3;5];[2;3;6]];;
# cartesian_product [[1;2];[];[4;5;6]] = [];;
# cartesian_product [[1;2];[3];[4];[5];[6]] |&gt; sort =
[[1;3;4;5;6];[2;3;4;5;6]];;</code></pre><p>invariant: <code>cartesian_product l = map_product id l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-map_product_l"><a href="#val-map_product_l" class="anchor"></a><code><span class="keyword">val</span> map_product_l : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> list</span> list</span></code></dt><dd><p><code>map_product_l f l</code> maps each element of <code>l</code> to a list of objects of type <code>'b</code> using <code>f</code>. We obtain <code>[l1; l2; …; ln]</code> where <code>length l=n</code> and <code>li : 'b list</code>. Then, it returns all the ways of picking exactly one element per <code>li</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-diagonal"><a href="#val-diagonal" class="anchor"></a><code><span class="keyword">val</span> diagonal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>diagonal l</code> returns all pairs of distinct positions of the list <code>l</code>, that is the list of <code>List.nth i l, List.nth j l</code> if <code>i &lt; j</code>.</p></dd></dl><dl><dt class="spec value" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span class="keyword">val</span> partition_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>[&lt; <span>`Left of <span class="type-var">'b</span></span> <span><span>| `Right</span> of <span class="type-var">'c</span></span> <span>| `Drop</span> ]</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></code></dt><dd><p><code>partition_map f l</code> maps <code>f</code> on <code>l</code> and gather results in lists:</p><ul><li>if <code>f x = `Left y</code>, adds <code>y</code> to the first list.</li><li>if <code>f x = `Right z</code>, adds <code>z</code> to the second list.</li><li>if <code>f x = `Drop</code>, ignores <code>x</code>.</li></ul><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_by"><a href="#val-group_by" class="anchor"></a><code><span class="keyword">val</span> group_by : <span>?&#8288;hash:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>group_by ?hash ?eq l</code> groups equal elements, regardless of their order of appearance. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span>join_row:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>join ~join_row a b</code> combines every element of <code>a</code> with every element of <code>b</code> using <code>join_row</code>. If <code>join_row</code> returns <code>None</code>, then the two elements do not combine. Assume that <code>b</code> allows for multiple iterations.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join_by"><a href="#val-join_by" class="anchor"></a><code><span class="keyword">val</span> join_by : <span>?&#8288;eq:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hash:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>)</span> <span>&#45;&gt;</span> <span>merge:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>join_by ?eq ?hash key1 key2 ~merge la lb</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and combine values <code>(x,y)</code> from <code>(a,b)</code> with the same <code>key</code> using <code>merge</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-join_all_by"><a href="#val-join_all_by" class="anchor"></a><code><span class="keyword">val</span> join_all_by : <span>?&#8288;eq:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'key</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hash:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>)</span> <span>&#45;&gt;</span> <span>merge:<span>(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>join_all_by ?eq ?hash key1 key2 ~merge la lb</code> is a binary operation that takes two sequences <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and, for each key <code>k</code> occurring in at least one of them:</p><ul><li>compute the list <code>l1</code> of elements of <code>a</code> that map to <code>k</code></li><li>compute the list <code>l2</code> of elements of <code>b</code> that map to <code>k</code></li><li>call <code>merge k l1 l2</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded, otherwise it returns <code>Some c</code> and <code>c</code> is inserted in the result.</li></ul><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_join_by"><a href="#val-group_join_by" class="anchor"></a><code><span class="keyword">val</span> group_join_by : <span>?&#8288;eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hash:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>group_join_by ?eq ?hash key la lb</code> associates to every element <code>x</code> of the first sequence, all the elements <code>y</code> of the second sequence such that <code>eq x (key y)</code>. Elements of the first sequences without corresponding values in the second one are mapped to <code>[]</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>2.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-sublists_of_len"><a href="#val-sublists_of_len" class="anchor"></a><code><span class="keyword">val</span> sublists_of_len : <span>?&#8288;last:<span>(<span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> option</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;offset:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>sublists_of_len ?last ?offset n l</code> returns sub-lists of <code>l</code> that have length <code>n</code>. By default, these sub-lists are non overlapping: <code>sublists_of_len 2 [1;2;3;4;5;6]</code> returns <code>[1;2]; [3;4]; [5;6]</code>.</p><p>Examples:</p><ul><li><code>sublists_of_len 2 [1;2;3;4;5;6] = [[1;2]; [3;4]; [5;6]]</code>.</li><li><code>sublists_of_len 2 ~offset:3 [1;2;3;4;5;6] = [1;2];[4;5]</code>.</li><li><code>sublists_of_len 3 ~last:CCOpt.return [1;2;3;4] = [1;2;3];[4]</code>.</li><li><code>sublists_of_len 2 [1;2;3;4;5] = [[1;2]; [3;4]]</code>.</li></ul><dl><dt>parameter offset</dt><dd><p>the number of elements skipped between two consecutive sub-lists. By default it is <code>n</code>. If <code>offset &lt; n</code>, the sub-lists will overlap; if <code>offset &gt; n</code>, some elements will not appear at all.</p></dd></dl><dl><dt>parameter last</dt><dd><p>if provided and the last group of elements <code>g</code> is such that <code>length g &lt; n</code>, <code>last g</code> is called. If <code>last g = Some g'</code>, <code>g'</code> is appended; otherwise <code>g</code> is dropped. If <code>last = CCOpt.return</code>, it will simply keep the last group. By default, <code>last = fun _ -&gt; None</code>, i.e. the last group is dropped if shorter than <code>n</code>.</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>offset &lt;= 0</code> or <code>n &lt;= 0</code>. See <a href="index.html#val-sublists_of_len"><code>CCList.sublists_of_len</code></a> for more details.</p></dd></dl><dl><dt>since</dt><dd>1.0, but only</dd></dl><dl><dt>since</dt><dd>1.5 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-chunks"><a href="#val-chunks" class="anchor"></a><code><span class="keyword">val</span> chunks : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>chunks n l</code> returns consecutives chunks of size at most <code>n</code> from <code>l</code>. Each item of <code>l</code> will occur in exactly one chunk. Only the last chunk might be of length smaller than <code>n</code>. Invariant: <code>(chunks n l |&gt; List.flatten) = l</code>.</p><dl><dt>since</dt><dd>3.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val</span> intersperse : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>intersperse x l</code> inserts the element <code>x</code> between adjacent elements of the list <code>l</code>.</p><dl><dt>since</dt><dd>2.1, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-interleave"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>interleave [x1…xn] [y1…ym]</code> is <code>[x1;y1;x2;y2;…]</code> and finishes with the suffix of the longest list.</p><dl><dt>since</dt><dd>2.1, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pure x</code> is <code>return x</code>.</p></dd></dl><dl><dt class="spec value" id="val-mguard"><a href="#val-mguard" class="anchor"></a><code><span class="keyword">val</span> mguard : bool <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mguard c</code> is <code>pure ()</code> if <code>c</code> is true, <code>[]</code> otherwise. This is useful to define a list by comprehension, e.g.:</p><pre><code class="ml"># let square_even xs =
      let* x = xs in
      let* () = mguard (x mod 2 = 0) in
      return @@ x * x;;
val square_even : int list -&gt; int list = &lt;fun&gt;
# square_even [1;2;4;3;5;2];;
- : int list = [4; 16; 4]</code></pre><dl><dt>since</dt><dd>3.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>funs &lt;*&gt; l</code> is <code>product (fun f x -&gt; f x) funs l</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;$&gt;)"><a href="#val-(&lt;$&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;$&gt;) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>(&lt;$&gt;)</code> is <code>map</code>.</p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>return x</code> is <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>l &gt;&gt;= f</code> is <code>flat_map f l</code>.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take n l</code> takes the <code>n</code> first elements of the list <code>l</code>, drop the rest.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>drop n l</code> drops the <code>n</code> first elements of the list <code>l</code>, keep the rest.</p></dd></dl><dl><dt class="spec value" id="val-hd_tl"><a href="#val-hd_tl" class="anchor"></a><code><span class="keyword">val</span> hd_tl : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>hd_tl (x :: l)</code> returns <code>hd, l</code>.</p><dl><dt>raises Failure</dt><dd><p>if the list is empty.</p></dd></dl><dl><dt>since</dt><dd>0.16</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_drop"><a href="#val-take_drop" class="anchor"></a><code><span class="keyword">val</span> take_drop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_drop n l</code> returns <code>l1, l2</code> such that <code>l1 @ l2 = l</code> and <code>length l1 = min (length l) n</code>.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_while f l</code> returns the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>drop_while f l</code> drops the longest prefix of <code>l</code> for which <code>f</code> is <code>true</code>.</p><dl><dt>since</dt><dd>0.13</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_drop_while"><a href="#val-take_drop_while" class="anchor"></a><code><span class="keyword">val</span> take_drop_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>take_drop_while p l</code> = <code>take_while p l, drop_while p l</code>.</p><dl><dt>since</dt><dd>1.2, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>last n l</code> takes the last <code>n</code> elements of <code>l</code> (or less if <code>l</code> doesn't have that many elements).</p></dd></dl><dl><dt class="spec value" id="val-head_opt"><a href="#val-head_opt" class="anchor"></a><code><span class="keyword">val</span> head_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>head_opt l</code> returns <code>Some x</code> (the first element of the list <code>l</code>) or <code>None</code> if the list <code>l</code> is empty.</p><dl><dt>since</dt><dd>0.20</dd></dl></dd></dl><dl><dt class="spec value" id="val-tail_opt"><a href="#val-tail_opt" class="anchor"></a><code><span class="keyword">val</span> tail_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> option</span></code></dt><dd><p><code>tail_opt l</code> returns <code>Some l'</code> (the given list <code>l</code> without its first element) or <code>None</code> if the list <code>l</code> is empty.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-last_opt"><a href="#val-last_opt" class="anchor"></a><code><span class="keyword">val</span> last_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>last_opt l</code> returns <code>Some x</code> (the last element of <code>l</code>) or <code>None</code> if the list <code>l</code> is empty.</p><dl><dt>since</dt><dd>0.20</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred"><a href="#val-find_pred" class="anchor"></a><code><span class="keyword">val</span> find_pred : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_pred p l</code> finds the first element of <code>l</code> that satisfies <code>p</code>, or returns <code>None</code> if no element satisfies <code>p</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_opt p l</code> is the safe version of <a href="index.html#val-find"><code>find</code></a>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred_exn"><a href="#val-find_pred_exn" class="anchor"></a><code><span class="keyword">val</span> find_pred_exn : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>find_pred_exn p l</code> is the unsafe version of <a href="index.html#val-find_pred"><code>find_pred</code></a>.</p><dl><dt>raises Not_found</dt><dd><p>if no such element is found.</p></dd></dl><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>find_map f l</code> traverses <code>l</code>, applying <code>f</code> to each element. If for some element <code>x</code>, <code>f x = Some y</code>, then <code>Some y</code> is returned. Otherwise the call returns <code>None</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val</span> find_mapi : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>find_mapi f l</code> is like <a href="index.html#val-find_map"><code>find_map</code></a>, but also pass the index to the predicate function.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_idx"><a href="#val-find_idx" class="anchor"></a><code><span class="keyword">val</span> find_idx : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(int * <span class="type-var">'a</span>)</span> option</span></code></dt><dd><p><code>find_idx p x</code> returns <code>Some (i,x)</code> where <code>x</code> is the <code>i</code>-th element of <code>l</code>, and <code>p x</code> holds. Otherwise returns <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>key:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove ~eq ~key l</code> removes every instance of <code>key</code> from <code>l</code>. Tail-recursive.</p><dl><dt>parameter eq</dt><dd><p>equality function.</p></dd></dl><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_map f l</code> is the sublist of <code>l</code> containing only elements for which <code>f</code> returns <code>Some e</code>. Map and remove elements at the same time.</p></dd></dl><dl><dt class="spec value" id="val-keep_some"><a href="#val-keep_some" class="anchor"></a><code><span class="keyword">val</span> keep_some : <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>keep_some l</code> retains only elements of the form <code>Some x</code>. Like <code>filter_map CCFun.id</code>.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-keep_ok"><a href="#val-keep_ok" class="anchor"></a><code><span class="keyword">val</span> keep_ok : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> Stdlib.result</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>keep_ok l</code> retains only elements of the form <code>Ok x</code>.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-all_some"><a href="#val-all_some" class="anchor"></a><code><span class="keyword">val</span> all_some : <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> option</span></code></dt><dd><p><code>all_some l</code> returns <code>Some l'</code> if all elements of <code>l</code> are of the form <code>Some x</code>, or <code>None</code> otherwise.</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-all_ok"><a href="#val-all_ok" class="anchor"></a><code><span class="keyword">val</span> all_ok : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'err</span>)</span> Stdlib.result</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>, <span class="type-var">'err</span>)</span> Stdlib.result</span></code></dt><dd><p><code>all_ok l</code> returns <code>Ok l'</code> if all elements of <code>l</code> are of the form <code>Ok x</code>, or <code>Error e</code> otherwise (with the first error met).</p><dl><dt>since</dt><dd>1.3, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-sorted_merge"><a href="#val-sorted_merge" class="anchor"></a><code><span class="keyword">val</span> sorted_merge : <span>cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sorted_merge ~cmp l1 l2</code> merges elements from both sorted list using the given comparison function <code>cmp</code>.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : <span>cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sort_uniq ~cmp l</code> sorts the list <code>l</code> using the given comparison function <code>cmp</code> and remove duplicate elements.</p></dd></dl><dl><dt class="spec value" id="val-sorted_merge_uniq"><a href="#val-sorted_merge_uniq" class="anchor"></a><code><span class="keyword">val</span> sorted_merge_uniq : <span>cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sorted_merge_uniq ~cmp l1 l2</code> merges the sorted lists <code>l1</code> and <code>l2</code> and removes duplicates.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_sorted"><a href="#val-is_sorted" class="anchor"></a><code><span class="keyword">val</span> is_sorted : <span>cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_sorted ~cmp l</code> returns <code>true</code> iff <code>l</code> is sorted (according to given order).</p><dl><dt>parameter cmp</dt><dd><p>the comparison function.</p></dd></dl><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-sorted_insert"><a href="#val-sorted_insert" class="anchor"></a><code><span class="keyword">val</span> sorted_insert : <span>cmp:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;uniq:bool</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>sorted_insert ~cmp ?uniq x l</code> inserts <code>x</code> into <code>l</code> such that, if <code>l</code> was sorted, then <code>sorted_insert x l</code> is sorted too.</p><dl><dt>parameter uniq</dt><dd><p>if <code>true</code> and <code>x</code> is already in sorted position in <code>l</code>, then <code>x</code> is not duplicated. Default <code>false</code> (<code>x</code> will be inserted in any case).</p></dd></dl><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-uniq_succ"><a href="#val-uniq_succ" class="anchor"></a><code><span class="keyword">val</span> uniq_succ : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>uniq_succ ~eq l</code> removes duplicate elements that occur one next to the other. Examples: <code>uniq_succ ~eq:(=) [1;2;1] = [1;2;1]</code>. <code>uniq_succ ~eq:(=) [1;1;2] = [1;2]</code>.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_succ"><a href="#val-group_succ" class="anchor"></a><code><span class="keyword">val</span> group_succ : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> list</span></code></dt><dd><p><code>group_succ ~eq l</code> groups together consecutive elements that are equal according to <code>eq</code>.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><section><header><h3 id="indices"><a href="#indices" class="anchor"></a>Indices</h3></header><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mapi f l</code> is like <a href="index.html#val-map"><code>map</code></a>, but the function <code>f</code> is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri f l</code> is like <a href="index.html#type-iter"><code>iter</code></a>, but the function <code>f</code> is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri2"><a href="#val-iteri2" class="anchor"></a><code><span class="keyword">val</span> iteri2 : <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri2 f l1 l2</code> applies <code>f</code> to the two lists <code>l1</code> and <code>l2</code> simultaneously. The integer passed to <code>f</code> indicates the index of element.</p><dl><dt>raises Invalid_argument</dt><dd><p>when lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>2.0, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>foldi f init l</code> is like <code>fold</code> but it also passes in the index of each element, from <code>0</code> to <code>length l - 1</code> as additional argument to the folded function <code>f</code>. Tail-recursive.</p></dd></dl><dl><dt class="spec value" id="val-foldi2"><a href="#val-foldi2" class="anchor"></a><code><span class="keyword">val</span> foldi2 : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>foldi2 f init l1 l2</code> folds on the two lists <code>l1</code> and <code>l2</code>, with index of each element passed to the function <code>f</code>. Computes <code>f(… (f init i_0 l1_0 l2_0) …) i_n l1_n l2_n</code> .</p><dl><dt>raises Invalid_argument</dt><dd><p>when lists do not have the same length.</p></dd></dl><dl><dt>since</dt><dd>2.0, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_at_idx"><a href="#val-get_at_idx" class="anchor"></a><code><span class="keyword">val</span> get_at_idx : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>get_at_idx i l</code> returns <code>Some i-th</code> element of the given list <code>l</code> or <code>None</code> if the list <code>l</code> is too short. If the index is negative, it will get element starting from the end of the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val</span> nth_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>nth_opt l n</code> returns <code>Some n-th</code> element of <code>l</code>. Safe version of <a href="index.html#val-nth"><code>nth</code></a>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the int is negative.</p></dd></dl><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.2 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_at_idx_exn"><a href="#val-get_at_idx_exn" class="anchor"></a><code><span class="keyword">val</span> get_at_idx_exn : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>get_at_idx_exn i l</code> gets the <code>i-th</code> element of <code>l</code>, or</p><dl><dt>raises Not_found</dt><dd><p>if the index is invalid. The first element has index 0. If the index is negative, it will get element starting from the end of the list.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-set_at_idx"><a href="#val-set_at_idx" class="anchor"></a><code><span class="keyword">val</span> set_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>set_at_idx i x l</code> replaces the <code>i-th</code> element with <code>x</code> (removes the old one), or does nothing if index is too high. If the index is negative, it will set element starting from the end of the list.</p></dd></dl><dl><dt class="spec value" id="val-insert_at_idx"><a href="#val-insert_at_idx" class="anchor"></a><code><span class="keyword">val</span> insert_at_idx : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>insert_at_idx i x l</code> inserts <code>x</code> at <code>i-th</code> position, between the two existing elements. If the index is too high, append at the end of the list. If the index is negative, it will insert element starting from the end of the list.</p></dd></dl><dl><dt class="spec value" id="val-remove_at_idx"><a href="#val-remove_at_idx" class="anchor"></a><code><span class="keyword">val</span> remove_at_idx : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove_at_idx i l</code> removes element at given index <code>i</code>. Does nothing if the index is too high. If the index is negative, it will remove element starting from the end of the list.</p></dd></dl></section><section><header><h3 id="set-operators"><a href="#set-operators" class="anchor"></a>Set Operators</h3><p>Those operations maintain the invariant that the list does not contain duplicates (if it already satisfies it).</p></header><dl><dt class="spec value" id="val-add_nodup"><a href="#val-add_nodup" class="anchor"></a><code><span class="keyword">val</span> add_nodup : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>add_nodup ~eq x set</code> adds <code>x</code> to <code>set</code> if it was not already present. Linear time.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_one"><a href="#val-remove_one" class="anchor"></a><code><span class="keyword">val</span> remove_one : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove_one ~eq x set</code> removes one occurrence of <code>x</code> from <code>set</code>. Linear time.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span>?&#8288;eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem ?eq x l</code> is <code>true</code> iff <code>x</code> is equal to an element of <code>l</code>. A comparator function <code>eq</code> can be provided. Linear time.</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset ~eq l1 l2</code> tests if all elements of the list <code>l1</code> are contained in the list <code>l2</code> by applying <code>eq</code>.</p></dd></dl><dl><dt class="spec value" id="val-uniq"><a href="#val-uniq" class="anchor"></a><code><span class="keyword">val</span> uniq : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>uniq ~eq l</code> removes duplicates in <code>l</code> w.r.t the equality predicate <code>eq</code>. Complexity is quadratic in the length of the list, but the order of elements is preserved. If you wish for a faster de-duplication but do not care about the order, use <a href="index.html#val-sort_uniq"><code>sort_uniq</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union ~eq l1 l2</code> is the union of the lists <code>l1</code> and <code>l2</code> w.r.t. the equality predicate <code>eq</code>. Complexity is product of length of inputs.</p></dd></dl><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>inter ~eq l1 l2</code> is the intersection of the lists <code>l1</code> and <code>l2</code> w.r.t. the equality predicate <code>eq</code>. Complexity is product of length of inputs.</p></dd></dl></section><section><header><h3 id="other-constructors"><a href="#other-constructors" class="anchor"></a>Other Constructors</h3></header><dl><dt class="spec value" id="val-range_by"><a href="#val-range_by" class="anchor"></a><code><span class="keyword">val</span> range_by : <span>step:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>range_by ~step i j</code> iterates on integers from <code>i</code> to <code>j</code> included, where the difference between successive elements is <code>step</code>. Use a negative <code>step</code> for a decreasing list.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>step=0</code>.</p></dd></dl><dl><dt>since</dt><dd>0.18</dd></dl></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>range i j</code> iterates on integers from <code>i</code> to <code>j</code> included. It works both for decreasing and increasing ranges.</p></dd></dl><dl><dt class="spec value" id="val-range'"><a href="#val-range'" class="anchor"></a><code><span class="keyword">val</span> range' : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>range' i j</code> is like <a href="index.html#val-range"><code>range</code></a> but the second bound <code>j</code> is excluded. For instance <code>range' 0 5 = [0;1;2;3;4]</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>i -- j</code> is the list of integers from <code>i</code> to <code>j</code> included. Infix alias for <code>range</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--^)"><a href="#val-(--^)" class="anchor"></a><code><span class="keyword">val</span> (--^) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>i --^ j</code> is the list of integers from <code>i</code> to <code>j</code> excluded. Infix alias for <code>range'</code>.</p><dl><dt>since</dt><dd>0.17</dd></dl></dd></dl><dl><dt class="spec value" id="val-replicate"><a href="#val-replicate" class="anchor"></a><code><span class="keyword">val</span> replicate : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>replicate n x</code> replicates the given element <code>x</code> <code>n</code> times.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>repeat n l</code> concatenates the list <code>l</code> with itself <code>n</code> times.</p></dd></dl></section><section><header><h3 id="association-lists"><a href="#association-lists" class="anchor"></a>Association Lists</h3></header><div class="spec module" id="module-Assoc"><a href="#module-Assoc" class="anchor"></a><code><span class="keyword">module</span> <a href="Assoc/index.html">Assoc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span class="keyword">val</span> assoc : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>assoc ~eq k alist</code> returns the value <code>v</code> associated with key <code>k</code> in <code>alist</code>. Like <code>Assoc.get_exn</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span class="keyword">val</span> assoc_opt : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>assoc_opt ~eq k alist</code> returns <code>Some v</code> if the given key <code>k</code> is present into <code>alist</code>, or <code>None</code> if not present. Like <code>Assoc.get</code>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.0 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span class="keyword">val</span> assq_opt : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>assq_opt k alist</code> returns <code>Some v</code> if the given key <code>k</code> is present into <code>alist</code>. Like <code>Assoc.assoc_opt</code> but use physical equality instead of structural equality to compare keys. Safe version of <a href="index.html#val-assq"><code>assq</code></a>.</p><dl><dt>since</dt><dd>1.5, but only</dd></dl><dl><dt>since</dt><dd>2.0 with labels</dd></dl></dd></dl><dl><dt class="spec value" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span class="keyword">val</span> mem_assoc : <span>?&#8288;eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>mem_assoc ?eq k alist</code> returns <code>true</code> iff <code>k</code> is a key in <code>alist</code>. Like <code>Assoc.mem</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span class="keyword">val</span> remove_assoc : <span>eq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>remove_assoc ~eq k alist</code> returns the <code>alist</code> without the first pair with key <code>k</code>, if any. Like <code>Assoc.remove</code>.</p><dl><dt>since</dt><dd>2.0</dd></dl></dd></dl></section><section><header><h3 id="references-on-lists"><a href="#references-on-lists" class="anchor"></a>References on Lists</h3><dl><dt>since</dt><dd>0.3.3</dd></dl></header><div class="spec module" id="module-Ref"><a href="#module-Ref" class="anchor"></a><code><span class="keyword">module</span> <a href="Ref/index.html">Ref</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-MONAD"><a href="#module-type-MONAD" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD/index.html">MONAD</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Traverse"><a href="#module-Traverse" class="anchor"></a><code><span class="keyword">module</span> <a href="Traverse/index.html">Traverse</a> : <span class="keyword">functor</span> (<a href="Traverse/argument-1-M/index.html">M</a> : <a href="index.html#module-type-MONAD">MONAD</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl></section><section><header><h3 id="conversions"><a href="#conversions" class="anchor"></a>Conversions</h3></header><dl><dt class="spec value" id="val-random"><a href="#val-random" class="anchor"></a><code><span class="keyword">val</span> random : <span><span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-random_gen">random_gen</a></span></code></dt><dt class="spec value" id="val-random_non_empty"><a href="#val-random_non_empty" class="anchor"></a><code><span class="keyword">val</span> random_non_empty : <span><span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-random_gen">random_gen</a></span></code></dt><dt class="spec value" id="val-random_len"><a href="#val-random_len" class="anchor"></a><code><span class="keyword">val</span> random_len : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-random_gen">random_gen</a></span></code></dt><dt class="spec value" id="val-random_choose"><a href="#val-random_choose" class="anchor"></a><code><span class="keyword">val</span> random_choose : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></span></code></dt><dd><p><code>random_choose l</code> randomly chooses an element in the list <code>l</code>.</p><dl><dt>raises Not_found</dt><dd><p>if the list is empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-random_sequence"><a href="#val-random_sequence" class="anchor"></a><code><span class="keyword">val</span> random_sequence : <span><span><span class="type-var">'a</span> <a href="index.html#type-random_gen">random_gen</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-random_gen">random_gen</a></span></code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>?&#8288;start:string</span> <span>&#45;&gt;</span> <span>?&#8288;stop:string</span> <span>&#45;&gt;</span> <span>?&#8288;sep:string</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string ?start ?stop ?sep item_to_string l</code> prints <code>l</code> to a string using <code>sep</code> as a separator between elements of <code>l</code>.</p><dl><dt>since</dt><dd>2.7</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_iter"><a href="#val-to_iter" class="anchor"></a><code><span class="keyword">val</span> to_iter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></span></code></dt><dd><p><code>to_iter l</code> returns a <code>iter</code> of the elements of the list <code>l</code>.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq l</code> returns a <code>Seq.t</code> of the elements of the list <code>l</code>. Renamed from <code>to_std_seq</code> since 3.0.</p><dl><dt>since</dt><dd>3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_iter"><a href="#val-of_iter" class="anchor"></a><code><span class="keyword">val</span> of_iter : <span><span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_iter iter</code> builds a list from a given <code>iter</code>. In the result, elements appear in the same order as they did in the source <code>iter</code>.</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq_rev"><a href="#val-of_seq_rev" class="anchor"></a><code><span class="keyword">val</span> of_seq_rev : <span><span class="type-var">'a</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_seq_rev seq</code> builds a list from a given <code>Seq.t</code>, in reverse order. Renamed from <code>to_std_seq_rev</code> since 3.0.</p><dl><dt>since</dt><dd>3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span class="type-var">'a</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_seq seq</code> builds a list from a given <code>Seq.t</code>. In the result, elements appear in the same order as they did in the source <code>Seq.t</code>. Renamed from <code>of_std_seq</code> since 3.0.</p><dl><dt>since</dt><dd>3.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_gen"><a href="#val-to_gen" class="anchor"></a><code><span class="keyword">val</span> to_gen : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span></code></dt><dd><p><code>to_gen l</code> returns a <code>gen</code> of the elements of the list <code>l</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_gen"><a href="#val-of_gen" class="anchor"></a><code><span class="keyword">val</span> of_gen : <span><span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_gen gen</code> builds a list from a given <code>gen</code>. In the result, elements appear in the same order as they did in the source <code>gen</code>.</p></dd></dl></section><section><header><h3 id="infix-operators"><a href="#infix-operators" class="anchor"></a>Infix Operators</h3><p>It is convenient to <code>open</code> <a href="Infix/index.html"><code>CCList.Infix</code></a> to access the infix operators without cluttering the scope too much.</p><dl><dt>since</dt><dd>0.16</dd></dl></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><p>Let operators on OCaml &gt;= 4.08.0, nothing otherwise</p><dl><dt>since</dt><dd>2.8</dd></dl><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../CCShimsMkLet_/index.html#module-type-S">CCShimsMkLet_.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../CCShimsMkLet_/module-type-S/index.html#type-t_let">t_let</a></span> := <span><span class="type-var">'a</span> list</span></code></span></summary><dl><dt class="spec type" id="type-t_let"><a href="#type-t_let" class="anchor"></a><code><span class="keyword">type</span> <span>'a t_let</span></code></dt></dl><dl><dt class="spec value" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t_let">t_let</a></span></code></dt><dt class="spec value" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span class="keyword">val</span> and+ : <span><span class="type-var">'a</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t_let">t_let</a></span></code></dt><dt class="spec value" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span class="keyword">val</span> let* : <span><span class="type-var">'a</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t_let">t_let</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t_let">t_let</a></span></code></dt><dt class="spec value" id="val-and*"><a href="#val-and*" class="anchor"></a><code><span class="keyword">val</span> and* : <span><span class="type-var">'a</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t_let">t_let</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t_let">t_let</a></span></code></dt></dl></details></div></div></div></section><section><header><h3 id="io"><a href="#io" class="anchor"></a>IO</h3></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span>?&#8288;pp_start:<span>unit <a href="index.html#type-printer">printer</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_stop:<span>unit <a href="index.html#type-printer">printer</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;pp_sep:<span>unit <a href="index.html#type-printer">printer</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-printer">printer</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-printer">printer</a></span></code></dt><dd><p><code>pp ?pp_start ?pp_stop ?pp_sep ppf l</code> prints the contents of a list.</p></dd></dl></section></div></body></html>